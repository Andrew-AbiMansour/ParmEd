

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>parmed.openmm.parameters &mdash; ParmEd  documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home" alt="Documentation Home"> ParmEd
          

          
          </a>

          
            
            
              <div class="version">
                0+untagged.3319.g7a6168d
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../topologyobjects.html">Core classes used to represent topologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../structure.html">The core Structure class</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dimensional_analysis.html">Working with units</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../readwrite.html">Reading and writing files</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../amber.html">The Amber file classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../charmm.html">The CHARMM file classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../gromacs.html">The GROMACS file classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../rosetta.html">PyRosetta Integration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../parmed.html">Using <code class="docutils literal notranslate"><span class="pre">parmed</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../parmed.html#using-xparmed">Using <code class="docutils literal notranslate"><span class="pre">xparmed</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../parmed_api.html">The ParmEd API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../openmm.html">OpenMM Functionality</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../visualization.html">Visualization Functionality</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">ParmEd</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>parmed.openmm.parameters</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for parmed.openmm.parameters</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module contains the class for storing and creating/converting/writing</span>
<span class="sd">OpenMM-style ffxml files defining a force field</span>

<span class="sd">Author(s): Jason Swails</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span>

<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">copy</span> <span class="k">as</span> <span class="n">_copy</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>
<span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">closing</span>
<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">from</span> <span class="nn">..charmm.parameters</span> <span class="kn">import</span> <span class="n">CharmmImproperMatchingMixin</span>
<span class="kn">from</span> <span class="nn">..constants</span> <span class="kn">import</span> <span class="n">DEFAULT_ENCODING</span>
<span class="kn">from</span> <span class="nn">..formats.registry</span> <span class="kn">import</span> <span class="n">FileFormatType</span>
<span class="kn">from</span> <span class="nn">..modeller.residue</span> <span class="kn">import</span> <span class="n">ResidueTemplate</span><span class="p">,</span> <span class="n">PatchTemplate</span>
<span class="kn">from</span> <span class="nn">..parameters</span> <span class="kn">import</span> <span class="n">ParameterSet</span>
<span class="kn">from</span> <span class="nn">..periodic_table</span> <span class="kn">import</span> <span class="n">Element</span>
<span class="kn">from</span> <span class="nn">..topologyobjects</span> <span class="kn">import</span> <span class="n">NoUreyBradley</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">unit</span> <span class="k">as</span> <span class="n">u</span>
<span class="kn">from</span> <span class="nn">..utils.io</span> <span class="kn">import</span> <span class="n">genopen</span>
<span class="kn">from</span> <span class="nn">..utils.six</span> <span class="kn">import</span> <span class="n">add_metaclass</span><span class="p">,</span> <span class="n">string_types</span><span class="p">,</span> <span class="n">iteritems</span>
<span class="kn">from</span> <span class="nn">..utils.six.moves</span> <span class="kn">import</span> <span class="nb">range</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">..exceptions</span> <span class="kn">import</span> <span class="n">ParameterWarning</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">product</span><span class="p">,</span> <span class="n">chain</span>
<span class="kn">from</span> <span class="nn">..topologyobjects</span> <span class="kn">import</span> <span class="p">(</span><span class="n">DihedralType</span><span class="p">,</span> <span class="n">ImproperType</span><span class="p">,</span> <span class="n">DrudeAtom</span><span class="p">)</span>


<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>

<span class="n">_have_lxml</span> <span class="o">=</span> <span class="kc">False</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">lxml</span> <span class="kn">import</span> <span class="n">etree</span>
    <span class="n">_have_lxml</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">xml.etree</span> <span class="kn">import</span> <span class="n">ElementTree</span> <span class="k">as</span> <span class="n">etree</span>

<span class="k">def</span> <span class="nf">_pretty_print_lxml</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">etree</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="n">DEFAULT_ENCODING</span><span class="p">,</span> <span class="n">pretty_print</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_pretty_print_xml_stdlib</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">xml.dom</span> <span class="kn">import</span> <span class="n">minidom</span>
    <span class="n">xml</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">getroot</span><span class="p">(),</span> <span class="n">encoding</span><span class="o">=</span><span class="n">DEFAULT_ENCODING</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">minidom</span><span class="o">.</span><span class="n">parseString</span><span class="p">(</span><span class="n">xml</span><span class="p">)</span><span class="o">.</span><span class="n">toprettyxml</span><span class="p">(</span><span class="n">indent</span><span class="o">=</span><span class="s2">&quot;  &quot;</span><span class="p">)</span>

<span class="k">if</span> <span class="n">_have_lxml</span><span class="p">:</span>
    <span class="n">pretty_print</span> <span class="o">=</span> <span class="n">_pretty_print_lxml</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">pretty_print</span> <span class="o">=</span> <span class="n">_pretty_print_xml_stdlib</span>

<span class="kn">import</span> <span class="nn">logging</span>
<span class="n">LOGGER</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<div class="viewcode-block" id="needs_lxml"><a class="viewcode-back" href="../../../api/parmed/parmed.openmm.parameters.html#parmed.openmm.needs_lxml">[docs]</a><span class="k">def</span> <span class="nf">needs_lxml</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Decorator to raise an ImportError if a function requires lxml but it is not</span>
<span class="sd">    present</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">etree</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s1">&#39;required package lxml could not be found&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper</span></div>

<div class="viewcode-block" id="OpenMMParameterSet"><a class="viewcode-back" href="../../../api/parmed/parmed.openmm.parameters.html#parmed.openmm.OpenMMParameterSet">[docs]</a><span class="nd">@add_metaclass</span><span class="p">(</span><span class="n">FileFormatType</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">OpenMMParameterSet</span><span class="p">(</span><span class="n">ParameterSet</span><span class="p">,</span> <span class="n">CharmmImproperMatchingMixin</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Class storing parameters from an OpenMM parameter set</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filenames : str, list of str, file-like, or list of file-like; optional</span>
<span class="sd">        Either the name of a file or a list of filenames from which parameters</span>
<span class="sd">        should be parsed.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Order is important in the list of files provided. The parameters are loaded</span>
<span class="sd">    in the order they are provided, and any parameters that are specified in</span>
<span class="sd">    multiple places are overwritten (that is, the *last* occurrence is the</span>
<span class="sd">    parameter type that is used)</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :class:`parmed.parameters.ParameterSet`</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="OpenMMParameterSet.id_format"><a class="viewcode-back" href="../../../api/parmed/parmed.openmm.parameters.html#parmed.openmm.OpenMMParameterSet.id_format">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">id_format</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Identifies the file type as either an Amber-style frcmod or parm.dat</span>
<span class="sd">        file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : str</span>
<span class="sd">            Name of the file to check format for</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        is_fmt : bool</span>
<span class="sd">            True if it is an Amber-style parameter file. False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Not implemented yet</span>
        <span class="k">return</span> <span class="kc">False</span></div>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">filenames</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">OpenMMParameterSet</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">filenames</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Cannot yet read OpenMM Parameter sets&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unique_atom_types</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_remediate_residue_template</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">residue</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Modify non-compliant residue templates to conform with OpenMM requirements.</span>

<span class="sd">        * To correctly detect waters, OpenMM ffxml water models must not contain</span>
<span class="sd">          non-chemical bond constraints. Theses are removed when importing</span>
<span class="sd">          foreign parameter sets (e.g., CHARMM) into OpenMM parameter sets,</span>
<span class="sd">          and not restored on conversion from OpenMM to other formats</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : :class:`parmed.parameters.ParameterSet`</span>
<span class="sd">            ParameterSet containing the list of parameters to be converted to a</span>
<span class="sd">            OpenMM-compatible parameter set</span>
<span class="sd">        residue : :class:`parmed.modeller.Residue`</span>
<span class="sd">            The residue to remediate</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        missing_parameters : bool</span>
<span class="sd">            If True, the residue template is missing some parameters</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Populate atomic numbers in residue template</span>
        <span class="c1"># TODO: This can be removed if the parameter readers are guaranteed to populate this correctly</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">residue</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">atom_types_str</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Residue </span><span class="si">{}</span><span class="s1"> contains atom type </span><span class="si">{}</span><span class="s1"> not found in parameter set and will be dropped.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">residue</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">atom</span><span class="o">.</span><span class="n">type</span><span class="p">))</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="n">atom</span><span class="o">.</span><span class="n">atomic_number</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">atom_types_str</span><span class="p">[</span><span class="n">atom</span><span class="o">.</span><span class="n">type</span><span class="p">]</span><span class="o">.</span><span class="n">atomic_number</span>

        <span class="c1"># CHARMM Drude force field lists all lone pairs as being hydrogens???  Fix them.</span>
        <span class="n">types</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">atom</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">atom</span><span class="o">.</span><span class="n">type</span><span class="p">)</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">residue</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">lonepair</span> <span class="ow">in</span> <span class="n">residue</span><span class="o">.</span><span class="n">lonepairs</span><span class="p">:</span>
            <span class="n">lp_atom</span> <span class="o">=</span> <span class="n">lonepair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">params</span><span class="o">.</span><span class="n">atom_types</span><span class="p">[</span><span class="n">types</span><span class="p">[</span><span class="n">lp_atom</span><span class="p">]]</span><span class="o">.</span><span class="n">atomic_number</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">residue</span><span class="p">[</span><span class="n">lp_atom</span><span class="p">]</span><span class="o">.</span><span class="n">atomic_number</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># CHARMM Drude force field includes bonds to lone pairs.  Delete them.</span>
        <span class="c1"># The call to list() makes a copy of the list, so we don&#39;t modify a list</span>
        <span class="c1"># we&#39;re iterating over.</span>
        <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">residue</span><span class="o">.</span><span class="n">bonds</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">.</span><span class="n">atom1</span><span class="o">.</span><span class="n">atomic_number</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">bond</span><span class="o">.</span><span class="n">atom2</span><span class="o">.</span><span class="n">atomic_number</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Deleting bonds to virtual sites in residue </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">residue</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
                <span class="n">residue</span><span class="o">.</span><span class="n">delete_bond</span><span class="p">(</span><span class="n">bond</span><span class="p">)</span>

        <span class="c1"># Check waters</span>
        <span class="k">if</span> <span class="n">residue</span><span class="o">.</span><span class="n">empirical_chemical_formula</span> <span class="o">==</span> <span class="s1">&#39;H2O&#39;</span><span class="p">:</span>
            <span class="c1"># Remove any H-H bonds if they are present</span>
            <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">residue</span><span class="o">.</span><span class="n">bonds</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">.</span><span class="n">atom1</span><span class="o">.</span><span class="n">element_name</span> <span class="o">==</span> <span class="s1">&#39;H&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">bond</span><span class="o">.</span><span class="n">atom2</span><span class="o">.</span><span class="n">element_name</span> <span class="o">==</span> <span class="s1">&#39;H&#39;</span><span class="p">):</span>
                    <span class="c1"># Remove nonphysical H-H bonds</span>
                    <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Deleting H-H bond from water residue </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">residue</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
                    <span class="n">residue</span><span class="o">.</span><span class="n">delete_bond</span><span class="p">(</span><span class="n">bond</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;keeping </span><span class="si">%s</span><span class="s1"> to </span><span class="si">%s</span><span class="s1"> </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">bond</span><span class="o">.</span><span class="n">atom1</span><span class="p">,</span> <span class="n">bond</span><span class="o">.</span><span class="n">atom2</span><span class="p">,</span> <span class="n">bond</span><span class="o">.</span><span class="n">atom2</span><span class="o">.</span><span class="n">element_name</span><span class="p">))</span>
        <span class="k">return</span> <span class="kc">True</span>

<div class="viewcode-block" id="OpenMMParameterSet.from_parameterset"><a class="viewcode-back" href="../../../api/parmed/parmed.openmm.parameters.html#parmed.openmm.OpenMMParameterSet.from_parameterset">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_parameterset</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">remediate_residues</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">unique_atom_types</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Instantiates an OpenMMParameterSet from another ParameterSet (or</span>
<span class="sd">        subclass). The main thing this feature is responsible for is converting</span>
<span class="sd">        lower-case atom type names into all upper-case and decorating the name</span>
<span class="sd">        to ensure each atom type name is unique.</span>

<span class="sd">        Warning</span>
<span class="sd">        -------</span>
<span class="sd">        Converting parameter sets to OpenMM can be lossy, and can modify the</span>
<span class="sd">        original parameter set unless ``copy=True``:</span>
<span class="sd">        * To correctly detect waters, OpenMM ffxml water models must not contain</span>
<span class="sd">          non-chemical bond constraints. Theses are removed when importing</span>
<span class="sd">          foreign parameter sets (e.g., CHARMM) into OpenMM parameter sets,</span>
<span class="sd">          and not restored on conversion from OpenMM to other formats.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : :class:`parmed.parameters.ParameterSet`</span>
<span class="sd">            ParameterSet containing the list of parameters to be converted to as</span>
<span class="sd">            OpenMM-compatible parameter set</span>
<span class="sd">        copy : bool, optional, default=False</span>
<span class="sd">            If True, the returned parameter set is a deep copy of ``params``. If</span>
<span class="sd">            False, the returned parameter set is a shallow copy. Default False.</span>
<span class="sd">        remediate_residues : bool, optional, default=True</span>
<span class="sd">            If True, will remove non-chemical bonds and drop Residue definitions</span>
<span class="sd">            that are missing parameters</span>
<span class="sd">        unique_atom_types : bool</span>
<span class="sd">            If True, a unique OpenMM atom type will be created for every atom of</span>
<span class="sd">            every residue.  In this case, the :class:`AtomType` objects correspond</span>
<span class="sd">            to atom classes rather than atom types (in the OpenMM terminology).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        new_params : OpenMMParameterSet</span>
<span class="sd">            OpenMMParameterSet with the same parameters as that defined in the</span>
<span class="sd">            input parameter set</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_params</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="c1"># Make a copy so we don&#39;t modify the original</span>
            <span class="n">params</span> <span class="o">=</span> <span class="n">_copy</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

        <span class="n">new_params</span><span class="o">.</span><span class="n">atom_types</span> <span class="o">=</span> <span class="n">new_params</span><span class="o">.</span><span class="n">atom_types_str</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">atom_types</span>
        <span class="n">new_params</span><span class="o">.</span><span class="n">atom_types_int</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">atom_types_int</span>
        <span class="n">new_params</span><span class="o">.</span><span class="n">atom_types_tuple</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">atom_types_tuple</span>
        <span class="n">new_params</span><span class="o">.</span><span class="n">bond_types</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">bond_types</span>
        <span class="n">new_params</span><span class="o">.</span><span class="n">angle_types</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">angle_types</span>
        <span class="n">new_params</span><span class="o">.</span><span class="n">urey_bradley_types</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">urey_bradley_types</span>
        <span class="n">new_params</span><span class="o">.</span><span class="n">dihedral_types</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">dihedral_types</span>
        <span class="n">new_params</span><span class="o">.</span><span class="n">improper_types</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">improper_types</span>
        <span class="n">new_params</span><span class="o">.</span><span class="n">improper_periodic_types</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">improper_periodic_types</span>
        <span class="n">new_params</span><span class="o">.</span><span class="n">rb_torsion_types</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">rb_torsion_types</span>
        <span class="n">new_params</span><span class="o">.</span><span class="n">cmap_types</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">cmap_types</span>
        <span class="n">new_params</span><span class="o">.</span><span class="n">nbfix_types</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">nbfix_types</span>
        <span class="n">new_params</span><span class="o">.</span><span class="n">pair_types</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">pair_types</span>
        <span class="n">new_params</span><span class="o">.</span><span class="n">parametersets</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">parametersets</span>
        <span class="n">new_params</span><span class="o">.</span><span class="n">_combining_rule</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">combining_rule</span>
        <span class="n">new_params</span><span class="o">.</span><span class="n">default_scee</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">default_scee</span>
        <span class="n">new_params</span><span class="o">.</span><span class="n">default_scnb</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">default_scnb</span>
        <span class="n">new_params</span><span class="o">.</span><span class="n">unique_atom_types</span> <span class="o">=</span> <span class="n">unique_atom_types</span>

        <span class="c1"># Copy CHARMM improper type map, if present, since this is needed for matching impropers</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="s1">&#39;_improper_key_map&#39;</span><span class="p">):</span>
            <span class="n">new_params</span><span class="o">.</span><span class="n">_improper_key_map</span> <span class="o">=</span> <span class="n">new_params</span><span class="o">.</span><span class="n">_improper_key_map</span>

        <span class="k">if</span> <span class="n">remediate_residues</span><span class="p">:</span>
            <span class="c1"># Add only ResidueTemplate instances (no ResidueTemplateContainers)</span>
            <span class="c1"># Maintain original residue ordering</span>
            <span class="n">remediated_residues</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">residue</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">params</span><span class="o">.</span><span class="n">residues</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">residue</span><span class="p">,</span> <span class="n">ResidueTemplate</span><span class="p">):</span>
                    <span class="c1"># Don&#39;t discard the residue, but fix it if we need to</span>
                    <span class="bp">cls</span><span class="o">.</span><span class="n">_remediate_residue_template</span><span class="p">(</span><span class="n">new_params</span><span class="p">,</span> <span class="n">residue</span><span class="p">)</span>
                    <span class="n">remediated_residues</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">residue</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">residue</span> <span class="ow">in</span> <span class="n">remediated_residues</span><span class="p">:</span>
                <span class="n">new_params</span><span class="o">.</span><span class="n">residues</span><span class="p">[</span><span class="n">residue</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">residue</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">patch</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">params</span><span class="o">.</span><span class="n">patches</span><span class="p">):</span>
                <span class="bp">cls</span><span class="o">.</span><span class="n">_remediate_residue_template</span><span class="p">(</span><span class="n">new_params</span><span class="p">,</span> <span class="n">patch</span><span class="p">)</span>
                <span class="n">new_params</span><span class="o">.</span><span class="n">patches</span><span class="p">[</span><span class="n">patch</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">patch</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Don&#39;t remediate residues; just copy</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">residue</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">params</span><span class="o">.</span><span class="n">residues</span><span class="p">):</span>
                <span class="n">new_params</span><span class="o">.</span><span class="n">residues</span><span class="p">[</span><span class="n">residue</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">residue</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">patch</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">params</span><span class="o">.</span><span class="n">patches</span><span class="p">):</span>
                <span class="n">new_params</span><span class="o">.</span><span class="n">patches</span><span class="p">[</span><span class="n">patch</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">patch</span>

        <span class="c1"># Only add unique patches</span>
        <span class="n">unique_patches</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">discarded_patches</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">patch</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">params</span><span class="o">.</span><span class="n">patches</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">patch</span><span class="p">,</span> <span class="n">PatchTemplate</span><span class="p">):</span>
                <span class="n">templhash</span> <span class="o">=</span> <span class="n">OpenMMParameterSet</span><span class="o">.</span><span class="n">_templhasher</span><span class="p">(</span><span class="n">patch</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">templhash</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">unique_patches</span><span class="p">:</span>
                    <span class="n">new_params</span><span class="o">.</span><span class="n">patches</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">patch</span>
                    <span class="n">unique_patches</span><span class="p">[</span><span class="n">templhash</span><span class="p">]</span> <span class="o">=</span> <span class="n">patch</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">patch_collision</span> <span class="o">=</span> <span class="n">unique_patches</span><span class="p">[</span><span class="n">templhash</span><span class="p">]</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Patch </span><span class="si">{}</span><span class="s1"> discarded because OpenMM considers it identical to </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">patch</span><span class="p">,</span> <span class="n">patch_collision</span><span class="p">))</span>
                    <span class="n">discarded_patches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">patch</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">discarded_patches</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> patches discarded, </span><span class="si">{}</span><span class="s1"> retained&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">discarded_patches</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_params</span><span class="o">.</span><span class="n">patches</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">patch</span> <span class="ow">in</span> <span class="n">discarded_patches</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">new_params</span><span class="o">.</span><span class="n">patches</span><span class="p">[</span><span class="n">patch</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">new_params</span></div>

    <span class="k">def</span> <span class="nf">_get_mm_atom_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="n">residue</span><span class="p">,</span> <span class="n">drude</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the OpenMM atom type for an atom.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atom : :class:`Atom`</span>
<span class="sd">            the atom for which to get the type</span>
<span class="sd">        residue : :class:`ResidueTemplate` or :class:`PatchTemplate`</span>
<span class="sd">            the residue the atom belongs to</span>
<span class="sd">        drude : bool</span>
<span class="sd">            if True, get the atom type for the Drude particle attached to the</span>
<span class="sd">            atom rather than the atom itself</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique_atom_types</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">drude</span><span class="p">:</span>
                <span class="k">return</span> <span class="s1">&#39;Drude-</span><span class="si">%s</span><span class="s1">-</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">residue</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">atom</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">-</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">residue</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">atom</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">drude</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">atom</span><span class="o">.</span><span class="n">drude_type</span>
        <span class="k">return</span> <span class="n">atom</span><span class="o">.</span><span class="n">type</span>

<div class="viewcode-block" id="OpenMMParameterSet.write"><a class="viewcode-back" href="../../../api/parmed/parmed.openmm.parameters.html#parmed.openmm.OpenMMParameterSet.write">[docs]</a>    <span class="nd">@needs_lxml</span>
    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">provenance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">write_unused</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">separate_ljforce</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
              <span class="n">improper_dihedrals_ordering</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="n">charmm_imp</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
              <span class="n">skip_duplicates</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Write the parameter set to an XML file for use with OpenMM</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dest : str or file-like</span>
<span class="sd">            The name of the file or the file-like object (with a ``write``</span>
<span class="sd">            attribute) to which the XML file will be written</span>
<span class="sd">        provenance : dict, optional</span>
<span class="sd">            If present, the XML file will be tagged with the available fields.</span>
<span class="sd">            Keys of the dictionary become XML etree.Element tags, the values of the</span>
<span class="sd">            dictionary must be instances of any of:</span>
<span class="sd">            - str / unicode (Py2) or str (Py3) - one XML element with this</span>
<span class="sd">            content is written</span>
<span class="sd">            - list - one XML element per each item of the list is written, all</span>
<span class="sd">            these XML elements use the same tag (key in provenance dict)</span>
<span class="sd">            - dict - one of the keys of this dict must be the same as the key of</span>
<span class="sd">            of the provenance dict under which this dict is nested. The value</span>
<span class="sd">            under this key becomes the content of the XML element. Remaining keys</span>
<span class="sd">            and their values are used to construct attributes of the XML element.</span>
<span class="sd">            Note that OrderedDict&#39;s should be used to ensure appropriate order</span>
<span class="sd">            of the XML elements and their attributes.</span>
<span class="sd">            Default is no provenance.</span>
<span class="sd">            Example (unordered):</span>
<span class="sd">            provenance = {&#39;Reference&#39; : [&#39;Nature&#39;, &#39;Cell&#39;],</span>
<span class="sd">                          &#39;Source&#39; : {&#39;Source&#39;: &#39;leaprc.ff14SB&#39;, sourcePackage :</span>
<span class="sd">                          &#39;AmberTools&#39;, sourcePackageVersion : &#39;15&#39;},</span>
<span class="sd">                          &#39;User&#39; : &#39;Mark&#39;}</span>
<span class="sd">        write_unused : bool</span>
<span class="sd">            If False: a) residue templates using unavailable atom types will not</span>
<span class="sd">            be written, b) atom types that are not used in any of the residue</span>
<span class="sd">            templates remaining and parameters including those atom types will</span>
<span class="sd">            not be written. A ParameterWarning is issued if any such residues are</span>
<span class="sd">            found in a).</span>
<span class="sd">        separate_ljforce : bool</span>
<span class="sd">            If True will use a separate LennardJonesForce to create a</span>
<span class="sd">            CostumNonbondedForce to compute L-J interactions. It will set sigma</span>
<span class="sd">            to 1 and epsilon to 0 in the NonbondedForce so that the</span>
<span class="sd">            NonbondedForce  only calculates the electrostatic contribution. It</span>
<span class="sd">            should be set to True when converting a CHARMM force field file that</span>
<span class="sd">            doesn&#39;t have pair-specific  L-J modifications (NBFIX in CHARMM) so</span>
<span class="sd">            that the ffxml conversion is compatible with the main charmm36.xml file.</span>
<span class="sd">            Note:</span>
<span class="sd">            ----</span>
<span class="sd">            When pair-specific L-J modifications are present (NBFIX in CHARMM), this</span>
<span class="sd">            behavior is always present and this flag is ignored.</span>
<span class="sd">        improper_dihedrals_ordering : str</span>
<span class="sd">            The ordering to use when assigning improper torsions in OpenMM.  Default is &#39;default&#39;,</span>
<span class="sd">            other option is &#39;amber&#39;</span>
<span class="sd">        charmm_imp: bool</span>
<span class="sd">            If True, will check for existence of IMPR in each residue and patch template,</span>
<span class="sd">            and write out the explicit improper definition without wildcards in the ffxml file.</span>
<span class="sd">        skip_duplicates : bool</span>
<span class="sd">            If True: residues which appear identical to an existing residue will</span>
<span class="sd">            not be written. This is usually the best choice. The most common</span>
<span class="sd">            reason for setting skip_duplicates to false is if you have different</span>
<span class="sd">            parametrizations for stereoisomers. Note that since OpenMM&#39;s residue</span>
<span class="sd">            hashing is not aware of chirality, if you wish to use the results in</span>
<span class="sd">            simulations you will need to explicitly provide the template names</span>
<span class="sd">            for affected residues.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The generated XML file will have the XML tag ``DateGenerated`` added to</span>
<span class="sd">        the provenance information set to the current date. Therefore, you</span>
<span class="sd">        should not provide this information in ``provenance`` (it will be</span>
<span class="sd">        removed if it is provided).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">write_unused</span><span class="p">:</span>
            <span class="n">skip_residues</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_unused_residues</span><span class="p">()</span>
            <span class="n">skip_types</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_unused_types</span><span class="p">(</span><span class="n">skip_residues</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">skip_residues</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Some residue templates using unavailable AtomTypes &#39;</span>
                              <span class="s1">&#39;were found. They will not be written to the ffxml &#39;</span>
                              <span class="s1">&#39;as write_unused is set to False&#39;</span><span class="p">,</span> <span class="n">ParameterWarning</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">skip_residues</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="n">skip_types</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom_types</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">typeify_templates</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Some residue templates are using unavailable &#39;</span>
                              <span class="s1">&#39;AtomTypes&#39;</span><span class="p">,</span> <span class="n">ParameterWarning</span><span class="p">)</span>

        <span class="p">[</span><span class="n">valid_residues_for_patch</span><span class="p">,</span> <span class="n">valid_patches_for_residue</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_determine_valid_patch_combinations</span><span class="p">(</span><span class="n">skip_residues</span><span class="p">)</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Valid patch combinations:&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">patch_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">patches</span><span class="p">:</span>
            <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%8s</span><span class="s1"> : </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">patch_name</span><span class="p">,</span> <span class="n">valid_residues_for_patch</span><span class="p">[</span><span class="n">patch_name</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">charmm_imp</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_find_explicit_impropers</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_compress_impropers</span><span class="p">()</span>

        <span class="n">root</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">Element</span><span class="p">(</span><span class="s1">&#39;ForceField&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_omm_provenance</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">provenance</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_omm_atom_types</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">skip_types</span><span class="p">,</span> <span class="n">skip_residues</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_omm_residues</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">skip_residues</span><span class="p">,</span> <span class="n">skip_duplicates</span><span class="p">,</span>
            <span class="n">valid_patches_for_residue</span><span class="o">=</span><span class="n">valid_patches_for_residue</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_omm_patches</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">valid_residues_for_patch</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_omm_bonds</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">skip_types</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_omm_angles</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">skip_types</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_omm_urey_bradley</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">skip_types</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_omm_dihedrals</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">skip_types</span><span class="p">,</span> <span class="n">improper_dihedrals_ordering</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_omm_impropers</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">skip_types</span><span class="p">)</span>
        <span class="c1">#self._write_omm_rb_torsions(root, skip_types)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_omm_cmaps</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">skip_types</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_omm_scripts</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">skip_types</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_omm_nonbonded</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">skip_types</span><span class="p">,</span> <span class="n">separate_ljforce</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_omm_LennardJonesForce</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">skip_types</span><span class="p">,</span> <span class="n">separate_ljforce</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_omm_DrudeForce</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">skip_types</span><span class="p">)</span>

        <span class="n">tree</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">ElementTree</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>

        <span class="n">xml</span> <span class="o">=</span> <span class="n">pretty_print</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="k">with</span> <span class="n">closing</span><span class="p">(</span><span class="n">genopen</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">))</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">xml</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dest</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">xml</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_find_explicit_impropers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For every residue, find any explicitly-specified (e.g. CHARMM) improper torsions and identify all wild-card improper parameters that match.</span>
<span class="sd">        Expand all of these out into explicit impropers.</span>
<span class="sd">        This is necessary for OpenMM to correctly handle impropers for these residues.</span>

<span class="sd">        .. todo ::</span>

<span class="sd">           * Do we need to do this for patches as well?</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Regenerate improper key map</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_improper_key_map</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">improper_types</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_improper_key_map</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">key</span><span class="p">))]</span> <span class="o">=</span> <span class="n">key</span>

        <span class="n">improper_harmonic</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span> <span class="c1"># improper_harmonic[key] is the harmonic improper parameter for unique key `key`</span>
        <span class="n">improper_periodic</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span> <span class="c1"># improper_harmonic[key] is the periodic improper parameter for unique key `key`</span>
        <span class="n">C_types</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom_types</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom_types</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">atomic_number</span> <span class="o">==</span> <span class="mi">6</span><span class="p">]</span>
        <span class="n">N_types</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom_types</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom_types</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">atomic_number</span> <span class="o">==</span> <span class="mi">7</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">get_types</span><span class="p">(</span><span class="n">residue</span><span class="p">,</span> <span class="n">atomname</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Return list of atom type(s) that match the given atom name.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">a_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">residue</span><span class="o">.</span><span class="n">atoms</span><span class="p">]</span>
            <span class="n">a_types</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">type</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">residue</span><span class="o">.</span><span class="n">atoms</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">atomname</span> <span class="o">==</span> <span class="s1">&#39;-C&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">C_types</span>
            <span class="k">elif</span> <span class="n">atomname</span> <span class="o">==</span> <span class="s1">&#39;+N&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">N_types</span>
            <span class="k">elif</span> <span class="n">atomname</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s1">&#39;+&#39;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unknown atom name </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">atomname</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span> <span class="n">a_types</span><span class="p">[</span><span class="n">a_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">atomname</span><span class="p">)]</span> <span class="p">]</span>

        <span class="c1"># Iterate over all residues</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">residue</span> <span class="ow">in</span> <span class="n">chain</span><span class="p">(</span><span class="n">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">residues</span><span class="p">),</span> <span class="n">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">patches</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">impr</span> <span class="ow">in</span> <span class="n">residue</span><span class="o">.</span><span class="n">_impr</span><span class="p">:</span>
                <span class="c1"># Get the list of types involved in this improper</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">types</span> <span class="o">=</span> <span class="p">[</span> <span class="n">get_types</span><span class="p">(</span><span class="n">residue</span><span class="p">,</span> <span class="n">atomname</span><span class="p">)</span> <span class="k">for</span> <span class="n">atomname</span> <span class="ow">in</span> <span class="n">impr</span> <span class="p">]</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">improper_found</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">types</span><span class="p">):</span>
                    <span class="c1"># Search for an improper that matches these types</span>
                    <span class="n">improper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">match_improper_type</span><span class="p">(</span><span class="o">*</span><span class="n">key</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">improper</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="c1"># Add this to our types</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">improper</span><span class="p">,</span> <span class="n">ImproperType</span><span class="p">):</span>
                        <span class="n">improper_harmonic</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">improper</span>
                        <span class="n">improper_found</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">improper</span><span class="p">,</span> <span class="n">DihedralType</span><span class="p">):</span>
                        <span class="n">improper_periodic</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">improper</span>
                        <span class="n">improper_found</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Something went wrong with improper type for </span><span class="si">{}</span><span class="s1"> returning an unexpected object </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">improper</span><span class="p">))</span>

                <span class="c1"># Warn if no improper was found</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">improper_found</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;No improper found for improper </span><span class="si">{}</span><span class="s1"> in residue </span><span class="si">{}</span><span class="s1"> (types were </span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">impr</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">types</span><span class="p">))</span>

        <span class="c1"># Update our impropers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">improper_periodic_types</span> <span class="o">=</span> <span class="n">improper_periodic</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">improper_types</span> <span class="o">=</span> <span class="n">improper_harmonic</span>

    <span class="k">def</span> <span class="nf">_compress_impropers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        OpenMM&#39;s ForceField cannot handle impropers that match the same four atoms</span>
<span class="sd">        in more than one order, so Peter Eastman wants us to compress duplicates</span>
<span class="sd">        and increment the spring constant accordingly.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">improper_types</span><span class="p">:</span> <span class="k">return</span>

        <span class="n">unique_keys</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span> <span class="c1"># unique_keys[key] is the key to retrieve the improper from improper_types</span>
        <span class="n">improper_types</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span> <span class="c1"># replacement for self.improper_types with compressed impropers</span>
        <span class="k">for</span> <span class="n">atoms</span><span class="p">,</span> <span class="n">improper</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">improper_types</span><span class="p">):</span>
            <span class="c1"># Compute a unique key</span>
            <span class="n">unique_key</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">atoms</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">unique_key</span> <span class="ow">in</span> <span class="n">unique_keys</span><span class="p">:</span>
                <span class="c1"># Accumulate spring constant, discarding this contribution</span>
                <span class="c1"># TODO: Do we need to check if `psi_eq` is the same?</span>
                <span class="n">atoms2</span> <span class="o">=</span> <span class="n">unique_keys</span><span class="p">[</span><span class="n">unique_key</span><span class="p">]</span>
                <span class="n">improper_types</span><span class="p">[</span><span class="n">atoms2</span><span class="p">]</span><span class="o">.</span><span class="n">psi_k</span> <span class="o">+=</span> <span class="n">improper</span><span class="o">.</span><span class="n">psi_k</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Compressing improper </span><span class="si">{}</span><span class="s1"> because it contains same atoms as </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">improper</span><span class="p">,</span> <span class="n">improper_types</span><span class="p">[</span><span class="n">atoms2</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Store this improper</span>
                <span class="n">unique_keys</span><span class="p">[</span><span class="n">unique_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">atoms</span>
                <span class="n">improper_types</span><span class="p">[</span><span class="n">atoms</span><span class="p">]</span> <span class="o">=</span> <span class="n">improper</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">improper_types</span> <span class="o">=</span> <span class="n">improper_types</span>

    <span class="k">def</span> <span class="nf">_find_unused_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">skip_residues</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">residue</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">residues</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">((</span><span class="n">atom</span><span class="o">.</span><span class="n">type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom_types</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">residue</span><span class="o">.</span><span class="n">atoms</span><span class="p">)):</span>
                <span class="n">skip_residues</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">skip_residues</span>

    <span class="k">def</span> <span class="nf">_find_unused_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">skip_residues</span><span class="p">):</span>
        <span class="n">keep_types</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">residue</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">residues</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">skip_residues</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">residue</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
                    <span class="n">keep_types</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">typ</span> <span class="k">for</span> <span class="n">typ</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom_types</span> <span class="k">if</span> <span class="n">typ</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">keep_types</span><span class="p">}</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_templhasher</span><span class="p">(</span><span class="n">residue</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a unique hash for each residue and patch template using only properties rendered to OpenMM ffxml.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hash_info</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">()</span>
        <span class="c1"># Sort tuples of atom properties by atom name</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">residue</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">hash_info</span> <span class="o">+=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span> <span class="p">[(</span><span class="n">atom</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">charge</span><span class="p">))</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">residue</span><span class="o">.</span><span class="n">atoms</span><span class="p">]</span> <span class="p">))</span>
        <span class="c1"># Sort list of deleted atoms by atom name</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">residue</span><span class="p">,</span> <span class="s1">&#39;delete_atoms&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">residue</span><span class="o">.</span><span class="n">delete_atoms</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">hash_info</span> <span class="o">+=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="n">atom_name</span> <span class="k">for</span> <span class="n">atom_name</span> <span class="ow">in</span> <span class="n">residue</span><span class="o">.</span><span class="n">delete_atoms</span><span class="p">]))</span>
        <span class="c1"># Sort list of bonds by first bond name</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">residue</span><span class="o">.</span><span class="n">bonds</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">hash_info</span> <span class="o">+=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span> <span class="p">[(</span><span class="n">bond</span><span class="o">.</span><span class="n">atom1</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">bond</span><span class="o">.</span><span class="n">atom2</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">.</span><span class="n">atom1</span><span class="o">.</span><span class="n">name</span> <span class="o">&lt;</span> <span class="n">bond</span><span class="o">.</span><span class="n">atom2</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="k">else</span> <span class="p">(</span><span class="n">bond</span><span class="o">.</span><span class="n">atom2</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">bond</span><span class="o">.</span><span class="n">atom1</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="n">residue</span><span class="o">.</span><span class="n">bonds</span><span class="p">]</span> <span class="p">))</span>
        <span class="c1"># Add head and tail</span>
        <span class="k">if</span> <span class="n">residue</span><span class="o">.</span><span class="n">head</span><span class="p">:</span>
            <span class="n">hash_info</span> <span class="o">+=</span> <span class="p">(</span><span class="n">residue</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">name</span><span class="p">,)</span>
        <span class="k">if</span> <span class="n">residue</span><span class="o">.</span><span class="n">tail</span><span class="p">:</span>
            <span class="n">hash_info</span> <span class="o">+=</span> <span class="p">(</span><span class="n">residue</span><span class="o">.</span><span class="n">tail</span><span class="o">.</span><span class="n">name</span><span class="p">,)</span>
        <span class="c1"># TODO: Is there any other data that is rendered to ffxml files we should include?</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="n">hash_info</span><span class="p">)</span>

    <span class="nd">@needs_lxml</span>
    <span class="k">def</span> <span class="nf">_write_omm_provenance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">provenance</span><span class="p">):</span>
        <span class="n">info</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s1">&#39;Info&#39;</span><span class="p">)</span>

        <span class="n">date_generated</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="s2">&quot;DateGenerated&quot;</span><span class="p">)</span>
        <span class="n">date_generated</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%02d</span><span class="s1">-</span><span class="si">%02d</span><span class="s1">-</span><span class="si">%02d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">timetuple</span><span class="p">()[:</span><span class="mi">3</span><span class="p">]</span>

        <span class="n">provenance</span> <span class="o">=</span> <span class="n">provenance</span> <span class="ow">or</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">tag</span><span class="p">,</span> <span class="n">content</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">provenance</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">tag</span> <span class="o">==</span> <span class="s1">&#39;DateGenerated&#39;</span><span class="p">:</span> <span class="k">continue</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">content</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">content</span> <span class="o">=</span> <span class="p">[</span><span class="n">content</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">sub_content</span> <span class="ow">in</span> <span class="n">content</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sub_content</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
                    <span class="n">item</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">Element</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span>
                    <span class="n">item</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">sub_content</span>
                    <span class="n">info</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sub_content</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sub_content</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">tag</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sub_content</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;Content of an attribute-containing element &#39;</span>
                                       <span class="s1">&#39;specified incorrectly.&#39;</span><span class="p">)</span>
                    <span class="n">attributes</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">sub_content</span> <span class="k">if</span> <span class="n">key</span> <span class="o">!=</span> <span class="n">tag</span><span class="p">]</span>
                    <span class="n">element_content</span> <span class="o">=</span> <span class="n">sub_content</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span>
                    <span class="n">attributes</span> <span class="o">=</span> <span class="p">{</span> <span class="n">k</span> <span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">sub_content</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="p">}</span>
                    <span class="n">item</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="o">**</span><span class="n">attributes</span><span class="p">)</span>
                    <span class="n">item</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">element_content</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Incorrect type of the </span><span class="si">%s</span><span class="s1"> element content&#39;</span> <span class="o">%</span> <span class="n">tag</span><span class="p">)</span>

    <span class="nd">@needs_lxml</span>
    <span class="k">def</span> <span class="nf">_write_omm_atom_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xml_root</span><span class="p">,</span> <span class="n">skip_types</span><span class="p">,</span> <span class="n">skip_residues</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom_types</span><span class="p">:</span> <span class="k">return</span>
        <span class="n">xml_section</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">xml_root</span><span class="p">,</span> <span class="s2">&quot;AtomTypes&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique_atom_types</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">residue</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">residues</span><span class="o">.</span><span class="n">values</span><span class="p">())</span><span class="o">+</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">patches</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="k">if</span> <span class="n">residue</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">skip_residues</span><span class="p">:</span> <span class="k">continue</span>
                <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">residue</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
                    <span class="n">atom_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom_types</span><span class="p">[</span><span class="n">atom</span><span class="o">.</span><span class="n">type</span><span class="p">]</span>
                    <span class="n">properties</span> <span class="o">=</span> <span class="p">{</span> <span class="s1">&#39;name&#39;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_mm_atom_type</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="n">residue</span><span class="p">),</span> <span class="s1">&#39;class&#39;</span> <span class="p">:</span> <span class="n">atom</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="s1">&#39;mass&#39;</span> <span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">atom_type</span><span class="o">.</span><span class="n">mass</span><span class="p">)</span> <span class="p">}</span>
                    <span class="k">if</span> <span class="n">atom_type</span><span class="o">.</span><span class="n">atomic_number</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;element&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">Element</span><span class="p">[</span><span class="n">atom_type</span><span class="o">.</span><span class="n">atomic_number</span><span class="p">])</span>
                    <span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">xml_section</span><span class="p">,</span> <span class="s1">&#39;Type&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">properties</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="n">DrudeAtom</span><span class="p">):</span>
                        <span class="n">properties</span> <span class="o">=</span> <span class="p">{</span> <span class="s1">&#39;name&#39;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_mm_atom_type</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="n">residue</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span> <span class="s1">&#39;class&#39;</span> <span class="p">:</span> <span class="n">atom</span><span class="o">.</span><span class="n">drude_type</span><span class="p">,</span> <span class="s1">&#39;mass&#39;</span> <span class="p">:</span> <span class="s1">&#39;0.0&#39;</span> <span class="p">}</span>
                        <span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">xml_section</span><span class="p">,</span> <span class="s1">&#39;Type&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">properties</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">atom_type</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atom_types</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">skip_types</span><span class="p">:</span> <span class="k">continue</span>
                <span class="k">assert</span> <span class="n">atom_type</span><span class="o">.</span><span class="n">atomic_number</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Atomic number not set!&#39;</span>
                <span class="n">properties</span> <span class="o">=</span> <span class="p">{</span> <span class="s1">&#39;name&#39;</span> <span class="p">:</span> <span class="n">name</span><span class="p">,</span> <span class="s1">&#39;class&#39;</span> <span class="p">:</span> <span class="n">name</span><span class="p">,</span> <span class="s1">&#39;mass&#39;</span> <span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">atom_type</span><span class="o">.</span><span class="n">mass</span><span class="p">)</span> <span class="p">}</span>
                <span class="k">if</span> <span class="n">atom_type</span><span class="o">.</span><span class="n">atomic_number</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">xml_section</span><span class="p">,</span> <span class="s1">&#39;Type&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">properties</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">element</span> <span class="o">=</span> <span class="n">Element</span><span class="p">[</span><span class="n">atom_type</span><span class="o">.</span><span class="n">atomic_number</span><span class="p">]</span>
                    <span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">xml_section</span><span class="p">,</span> <span class="s1">&#39;Type&#39;</span><span class="p">,</span> <span class="n">element</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">element</span><span class="p">),</span> <span class="o">**</span><span class="n">properties</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_lonepair_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lonepair</span><span class="p">):</span>
        <span class="p">(</span><span class="n">lptype</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">,</span> <span class="n">a4</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span> <span class="o">=</span> <span class="n">lonepair</span>
        <span class="k">if</span> <span class="n">lptype</span> <span class="o">==</span> <span class="s1">&#39;relative&#39;</span><span class="p">:</span>
            <span class="n">xweights</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">lptype</span> <span class="o">==</span> <span class="s1">&#39;bisector&#39;</span><span class="p">:</span>
            <span class="n">xweights</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unknown lonepair type: &#39;</span><span class="o">+</span><span class="n">lptype</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">/=</span> <span class="mf">10.0</span> <span class="c1"># convert to nanometers</span>
        <span class="n">theta</span> <span class="o">*=</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">180.0</span> <span class="c1"># convert to radians</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="p">(</span><span class="mi">180</span> <span class="o">-</span> <span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">180.0</span> <span class="c1"># convert to radians</span>
        <span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="n">r</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">),</span> <span class="n">r</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)]</span>
        <span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1e-10</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">p</span><span class="p">]</span> <span class="c1"># Avoid tiny numbers caused by roundoff error</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s2">&quot;localCoords&quot;</span><span class="p">,</span>
            <span class="n">siteName</span><span class="o">=</span><span class="n">a1</span><span class="p">,</span> <span class="n">atomName1</span><span class="o">=</span><span class="n">a2</span><span class="p">,</span> <span class="n">atomName2</span><span class="o">=</span><span class="n">a3</span><span class="p">,</span> <span class="n">atomName3</span><span class="o">=</span><span class="n">a4</span><span class="p">,</span>
            <span class="n">wo1</span><span class="o">=</span><span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="n">wo2</span><span class="o">=</span><span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="n">wo3</span><span class="o">=</span><span class="s2">&quot;0&quot;</span><span class="p">,</span>
            <span class="n">wx1</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">xweights</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">wx2</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">xweights</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">wx3</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">xweights</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
            <span class="n">wy1</span><span class="o">=</span><span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="n">wy2</span><span class="o">=</span><span class="s2">&quot;-1&quot;</span><span class="p">,</span> <span class="n">wy3</span><span class="o">=</span><span class="s2">&quot;1&quot;</span><span class="p">,</span>
            <span class="n">p1</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">p2</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">p3</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>

    <span class="nd">@needs_lxml</span>
    <span class="k">def</span> <span class="nf">_write_omm_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xml_root</span><span class="p">,</span> <span class="n">skip_residues</span><span class="p">,</span> <span class="n">skip_duplicates</span><span class="p">,</span> <span class="n">valid_patches_for_residue</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">residues</span><span class="p">:</span> <span class="k">return</span>
        <span class="k">if</span> <span class="n">valid_patches_for_residue</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">valid_patches_for_residue</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">written_residues</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">xml_section</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">xml_root</span><span class="p">,</span> <span class="s1">&#39;Residues&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">residue</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">residues</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">skip_residues</span><span class="p">:</span> <span class="k">continue</span>
            <span class="n">templhash</span> <span class="o">=</span> <span class="n">OpenMMParameterSet</span><span class="o">.</span><span class="n">_templhasher</span><span class="p">(</span><span class="n">residue</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">templhash</span> <span class="ow">in</span> <span class="n">written_residues</span><span class="p">:</span>
                <span class="n">residue_collision</span> <span class="o">=</span> <span class="n">written_residues</span><span class="p">[</span><span class="n">templhash</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">skip_duplicates</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Skipping writing of residue </span><span class="si">{}</span><span class="s1"> because OpenMM considers it identical to </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">residue</span><span class="p">,</span> <span class="n">residue_collision</span><span class="p">))</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Residue </span><span class="si">{}</span><span class="s1"> will be considered by OpenMM to be identical to </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">residue</span><span class="p">,</span> <span class="n">residue_collision</span><span class="p">))</span>
            <span class="n">written_residues</span><span class="p">[</span><span class="n">templhash</span><span class="p">]</span> <span class="o">=</span> <span class="n">residue</span>
            <span class="c1"># Write residue</span>
            <span class="k">if</span> <span class="n">residue</span><span class="o">.</span><span class="n">override_level</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">xml_residue</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">xml_section</span><span class="p">,</span> <span class="s1">&#39;Residue&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">residue</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">xml_residue</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">xml_section</span><span class="p">,</span> <span class="s1">&#39;Residue&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">residue</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">override</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">residue</span><span class="o">.</span><span class="n">override_level</span><span class="p">))</span>
            <span class="c1"># Write residue contents</span>
            <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">residue</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="n">DrudeAtom</span><span class="p">):</span>
                    <span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">xml_residue</span><span class="p">,</span> <span class="s1">&#39;Atom&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">atom</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_mm_atom_type</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="n">residue</span><span class="p">),</span> <span class="n">charge</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">charge</span><span class="o">-</span><span class="n">atom</span><span class="o">.</span><span class="n">drude_charge</span><span class="p">))</span>
                    <span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">xml_residue</span><span class="p">,</span> <span class="s1">&#39;Atom&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;D&#39;</span><span class="o">+</span><span class="n">atom</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_mm_atom_type</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="n">residue</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span> <span class="n">charge</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">drude_charge</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">xml_residue</span><span class="p">,</span> <span class="s1">&#39;Atom&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">atom</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_mm_atom_type</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="n">residue</span><span class="p">),</span> <span class="n">charge</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">charge</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="n">residue</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
                <span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">xml_residue</span><span class="p">,</span> <span class="s1">&#39;Bond&#39;</span><span class="p">,</span> <span class="n">atomName1</span><span class="o">=</span><span class="n">bond</span><span class="o">.</span><span class="n">atom1</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">atomName2</span><span class="o">=</span><span class="n">bond</span><span class="o">.</span><span class="n">atom2</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">lonepair</span> <span class="ow">in</span> <span class="n">residue</span><span class="o">.</span><span class="n">lonepairs</span><span class="p">:</span>
                <span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">xml_residue</span><span class="p">,</span> <span class="s1">&#39;VirtualSite&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_lonepair_parameters</span><span class="p">(</span><span class="n">lonepair</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">residue</span><span class="o">.</span><span class="n">connections</span><span class="p">:</span>
                <span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">xml_residue</span><span class="p">,</span> <span class="s1">&#39;ExternalBond&#39;</span><span class="p">,</span> <span class="n">atomName</span><span class="o">=</span><span class="n">atom</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">residue</span><span class="o">.</span><span class="n">head</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">xml_residue</span><span class="p">,</span> <span class="s1">&#39;ExternalBond&#39;</span><span class="p">,</span> <span class="n">atomName</span><span class="o">=</span><span class="n">residue</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">residue</span><span class="o">.</span><span class="n">tail</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">residue</span><span class="o">.</span><span class="n">tail</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">residue</span><span class="o">.</span><span class="n">head</span><span class="p">:</span>
                <span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">xml_residue</span><span class="p">,</span> <span class="s1">&#39;ExternalBond&#39;</span><span class="p">,</span> <span class="n">atomName</span><span class="o">=</span><span class="n">residue</span><span class="o">.</span><span class="n">tail</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">residue</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">valid_patches_for_residue</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">patch_name</span> <span class="ow">in</span> <span class="n">valid_patches_for_residue</span><span class="p">[</span><span class="n">residue</span><span class="o">.</span><span class="n">name</span><span class="p">]:</span>
                    <span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">xml_residue</span><span class="p">,</span> <span class="s1">&#39;AllowPatch&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">patch_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_determine_valid_patch_combinations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">skip_residues</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine valid (permissible) combinations of patches with residues that</span>
<span class="sd">        lead to integral net charges.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        skip_residues : set of ResidueTemplate</span>
<span class="sd">            List of residues to skip</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        valid_residues_for_patch : dict</span>
<span class="sd">            valid_residues_for_patch[patch] is a list of residues compatible with that patch</span>
<span class="sd">        valid_patches_for_residue : dict</span>
<span class="sd">            valid_patches_for_residue[residue] is a list of patches compatible with that residue</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Attempt to patch every residue, recording only valid combinations.</span>
        <span class="n">valid_residues_for_patch</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">patch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">patches</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">valid_residues_for_patch</span><span class="p">[</span><span class="n">patch</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">valid_patches_for_residue</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">residue</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">residues</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">valid_patches_for_residue</span><span class="p">[</span><span class="n">residue</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

        <span class="c1"># Create list of residues to check compatibility against</span>
        <span class="n">residues</span> <span class="o">=</span> <span class="p">[</span> <span class="n">residue</span> <span class="k">for</span> <span class="n">residue</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">residues</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">if</span> <span class="p">(</span><span class="n">residue</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">skip_residues</span><span class="p">)</span> <span class="p">]</span>

        <span class="c1"># Check patch compatibilities</span>
        <span class="k">for</span> <span class="n">patch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">patches</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">residue_compatibilities</span> <span class="o">=</span> <span class="p">[</span> <span class="n">residue</span><span class="o">.</span><span class="n">patch_is_compatible</span><span class="p">(</span><span class="n">patch</span><span class="p">)</span> <span class="k">for</span> <span class="n">residue</span> <span class="ow">in</span> <span class="n">residues</span> <span class="p">]</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">residue</span><span class="p">,</span> <span class="n">is_compatible</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">residues</span><span class="p">,</span> <span class="n">residue_compatibilities</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">is_compatible</span><span class="p">:</span>
                    <span class="n">valid_residues_for_patch</span><span class="p">[</span><span class="n">patch</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">residue</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                    <span class="n">valid_patches_for_residue</span><span class="p">[</span><span class="n">residue</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">patch</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">valid_residues_for_patch</span><span class="p">,</span> <span class="n">valid_patches_for_residue</span><span class="p">]</span>

    <span class="nd">@needs_lxml</span>
    <span class="k">def</span> <span class="nf">_write_omm_patches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xml_root</span><span class="p">,</span> <span class="n">valid_residues_for_patch</span><span class="p">,</span> <span class="n">write_apply_to_residue</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write patch definitions for OpenMM ForceField</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xml_root : lxml.etree.Element</span>
<span class="sd">            The XML Element write the &lt;Patches&gt; section to.</span>
<span class="sd">        valid_residues_for_patch : dict of str : str</span>
<span class="sd">            valid_residues_for_patch[patch_name] lists the residue names valid for this patch</span>
<span class="sd">        write_apply_to_residue : bool, optional, default=False</span>
<span class="sd">            If True, will write &lt;ApplyToResidue&gt; tags.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">patches</span><span class="p">:</span> <span class="k">return</span>
        <span class="n">written_patches</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">xml_patches</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">xml_root</span><span class="p">,</span> <span class="s1">&#39;Patches&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">patch</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">patches</span><span class="p">):</span>
            <span class="c1"># Require that at least one valid patch combination exists for this patch</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid_residues_for_patch</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">valid_residues_for_patch</span><span class="p">[</span><span class="n">name</span><span class="p">])</span><span class="o">==</span><span class="mi">0</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="n">templhash</span> <span class="o">=</span> <span class="n">OpenMMParameterSet</span><span class="o">.</span><span class="n">_templhasher</span><span class="p">(</span><span class="n">patch</span><span class="p">)</span> <span class="c1"># TODO: this may be redundant now</span>
            <span class="k">if</span> <span class="n">templhash</span> <span class="ow">in</span> <span class="n">written_patches</span><span class="p">:</span>
                <span class="n">patch_collision</span> <span class="o">=</span> <span class="n">written_patches</span><span class="p">[</span><span class="n">templhash</span><span class="p">]</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Skipping writing of patch </span><span class="si">{}</span><span class="s1"> because OpenMM considers it identical to </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">patch</span><span class="p">,</span> <span class="n">patch_collision</span><span class="p">))</span>
                <span class="k">continue</span>
            <span class="n">written_patches</span><span class="p">[</span><span class="n">templhash</span><span class="p">]</span> <span class="o">=</span> <span class="n">patch</span>
            <span class="k">if</span> <span class="n">patch</span><span class="o">.</span><span class="n">override_level</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">patch_xml</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">xml_patches</span><span class="p">,</span> <span class="s1">&#39;Patch&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">patch</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">patch_xml</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">xml_patches</span><span class="p">,</span> <span class="s1">&#39;Patch&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">patch</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">override</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">patch</span><span class="o">.</span><span class="n">override_level</span><span class="p">))</span>

            <span class="c1"># To generate the patch definition, we need to apply it to a residue and see exactly what</span>
            <span class="c1"># changes.  We might get different definitions depending on which residue we pick, so try</span>
            <span class="c1"># all possible residues to take the most common result.</span>

            <span class="n">versions</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">residue_name</span> <span class="ow">in</span> <span class="n">valid_residues_for_patch</span><span class="p">[</span><span class="n">name</span><span class="p">]:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">residue</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">residues</span><span class="p">[</span><span class="n">residue_name</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span>  <span class="s1">&#39;Compatible residue not found in self.residues</span><span class="se">\n</span><span class="s1">&#39;</span>
                    <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;   patch name: </span><span class="si">%s</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">name</span>
                    <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;   valid patch combinations: </span><span class="si">%s</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">valid_residues_for_patch</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                    <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;   residue name: </span><span class="si">%s</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">residue_name</span>
                    <span class="n">msg</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                    <span class="k">raise</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="n">patched_residue</span> <span class="o">=</span> <span class="n">residue</span><span class="o">.</span><span class="n">apply_patch</span><span class="p">(</span><span class="n">patch</span><span class="p">)</span>

                <span class="n">instructions</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">patch</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">residue</span><span class="p">:</span>
                        <span class="n">command</span> <span class="o">=</span> <span class="s1">&#39;AddAtom&#39;</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">command</span> <span class="o">=</span> <span class="s1">&#39;ChangeAtom&#39;</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="n">DrudeAtom</span><span class="p">):</span>
                        <span class="n">instructions</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">command</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">atom</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_mm_atom_type</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="n">patch</span><span class="p">),</span> <span class="n">charge</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">charge</span><span class="o">-</span><span class="n">atom</span><span class="o">.</span><span class="n">drude_charge</span><span class="p">))))</span>
                        <span class="n">instructions</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">command</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;D&#39;</span><span class="o">+</span><span class="n">atom</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_mm_atom_type</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="n">patch</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span> <span class="n">charge</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">drude_charge</span><span class="p">))))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">instructions</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">command</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">atom</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_mm_atom_type</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="n">patch</span><span class="p">),</span> <span class="n">charge</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">charge</span><span class="p">))))</span>

                <span class="k">for</span> <span class="n">atom_name</span> <span class="ow">in</span> <span class="n">patch</span><span class="o">.</span><span class="n">delete_atoms</span><span class="p">:</span>
                    <span class="n">instructions</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;RemoveAtom&#39;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">atom_name</span><span class="p">)))</span>

                <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="n">patch</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
                    <span class="n">instructions</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;RemoveBond&#39;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">atomName1</span><span class="o">=</span><span class="n">bond</span><span class="o">.</span><span class="n">atom1</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">atomName2</span><span class="o">=</span><span class="n">bond</span><span class="o">.</span><span class="n">atom2</span><span class="o">.</span><span class="n">name</span><span class="p">)))</span>

                <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="n">patched_residue</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">.</span><span class="n">atom1</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">residue</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">bond</span><span class="o">.</span><span class="n">atom2</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">residue</span><span class="p">):</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">.</span><span class="n">atom1</span><span class="o">.</span><span class="n">atomic_number</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">bond</span><span class="o">.</span><span class="n">atom2</span><span class="o">.</span><span class="n">atomic_number</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span> <span class="c1"># CHARMM adds bonds to lone pairs, which we need to omit.</span>
                            <span class="n">instructions</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;AddBond&#39;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">atomName1</span><span class="o">=</span><span class="n">bond</span><span class="o">.</span><span class="n">atom1</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">atomName2</span><span class="o">=</span><span class="n">bond</span><span class="o">.</span><span class="n">atom2</span><span class="o">.</span><span class="n">name</span><span class="p">)))</span>
                <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="n">residue</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">.</span><span class="n">atom1</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">patched_residue</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">bond</span><span class="o">.</span><span class="n">atom2</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">patched_residue</span><span class="p">):</span>
                        <span class="n">instructions</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;RemoveBond&#39;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">atomName1</span><span class="o">=</span><span class="n">bond</span><span class="o">.</span><span class="n">atom1</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">atomName2</span><span class="o">=</span><span class="n">bond</span><span class="o">.</span><span class="n">atom2</span><span class="o">.</span><span class="n">name</span><span class="p">)))</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">residue</span><span class="o">.</span><span class="n">head</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">patched_residue</span><span class="o">.</span><span class="n">head</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                    <span class="n">instructions</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;RemoveExternalBond&#39;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">atomName</span><span class="o">=</span><span class="n">residue</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">name</span><span class="p">)))</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">residue</span><span class="o">.</span><span class="n">tail</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">patched_residue</span><span class="o">.</span><span class="n">tail</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                    <span class="n">instructions</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;RemoveExternalBond&#39;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">atomName</span><span class="o">=</span><span class="n">residue</span><span class="o">.</span><span class="n">tail</span><span class="o">.</span><span class="n">name</span><span class="p">)))</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">residue</span><span class="o">.</span><span class="n">head</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">patched_residue</span><span class="o">.</span><span class="n">head</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                    <span class="n">instructions</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;AddExternalBond&#39;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">atomName</span><span class="o">=</span><span class="n">patched_residue</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">name</span><span class="p">)))</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">residue</span><span class="o">.</span><span class="n">tail</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">patched_residue</span><span class="o">.</span><span class="n">tail</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                    <span class="n">instructions</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;AddExternalBond&#39;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">atomName</span><span class="o">=</span><span class="n">patched_residue</span><span class="o">.</span><span class="n">tail</span><span class="o">.</span><span class="n">name</span><span class="p">)))</span>
                <span class="k">for</span> <span class="n">lonepair</span> <span class="ow">in</span> <span class="n">patch</span><span class="o">.</span><span class="n">lonepairs</span><span class="p">:</span>
                    <span class="n">instructions</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;VirtualSite&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_lonepair_parameters</span><span class="p">(</span><span class="n">lonepair</span><span class="p">)))</span>

                <span class="k">if</span> <span class="n">write_apply_to_residue</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">residue_name</span> <span class="ow">in</span> <span class="n">valid_residues_for_patch</span><span class="p">[</span><span class="n">patch</span><span class="o">.</span><span class="n">name</span><span class="p">]:</span>
                        <span class="n">instructions</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;ApplyToResidue&#39;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">residue_name</span><span class="p">)))</span>

                <span class="c1"># Convert to hashable types</span>
                <span class="n">instructions</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">((</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">instructions</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">instructions</span> <span class="ow">in</span> <span class="n">versions</span><span class="p">:</span>
                    <span class="n">versions</span><span class="p">[</span><span class="n">instructions</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">versions</span><span class="p">[</span><span class="n">instructions</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="c1"># Write the consensus definition.</span>
            <span class="n">max_count</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">versions</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
            <span class="n">instructions</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">versions</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="n">max_count</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">command</span><span class="p">,</span> <span class="n">attrib</span> <span class="ow">in</span> <span class="n">instructions</span><span class="p">:</span>
                <span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">patch_xml</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">attrib</span><span class="p">))</span>

    <span class="nd">@needs_lxml</span>
    <span class="k">def</span> <span class="nf">_write_omm_bonds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xml_root</span><span class="p">,</span> <span class="n">skip_types</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">bond_types</span><span class="p">:</span> <span class="k">return</span>
        <span class="n">xml_force</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">xml_root</span><span class="p">,</span> <span class="s1">&#39;HarmonicBondForce&#39;</span><span class="p">)</span>
        <span class="n">bonds_done</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">lconv</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">angstroms</span><span class="o">.</span><span class="n">conversion_factor_to</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">nanometers</span><span class="p">)</span>
        <span class="n">kconv</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">kilocalorie</span><span class="o">.</span><span class="n">conversion_factor_to</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">kilojoule</span><span class="p">)</span> <span class="o">/</span> <span class="n">lconv</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">),</span> <span class="n">bond</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bond_types</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">((</span><span class="n">a</span> <span class="ow">in</span> <span class="n">skip_types</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">))):</span> <span class="k">continue</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">bonds_done</span><span class="p">:</span> <span class="k">continue</span>
            <span class="n">bonds_done</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">))</span>
            <span class="n">bonds_done</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">a2</span><span class="p">,</span> <span class="n">a1</span><span class="p">))</span>
            <span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">xml_force</span><span class="p">,</span> <span class="s1">&#39;Bond&#39;</span><span class="p">,</span> <span class="n">class1</span><span class="o">=</span><span class="n">a1</span><span class="p">,</span> <span class="n">class2</span><span class="o">=</span><span class="n">a2</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">bond</span><span class="o">.</span><span class="n">req</span><span class="o">*</span><span class="n">lconv</span><span class="p">),</span> <span class="n">k</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">bond</span><span class="o">.</span><span class="n">k</span><span class="o">*</span><span class="n">kconv</span><span class="p">))</span>

    <span class="nd">@needs_lxml</span>
    <span class="k">def</span> <span class="nf">_write_omm_angles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xml_root</span><span class="p">,</span> <span class="n">skip_types</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle_types</span><span class="p">:</span> <span class="k">return</span>
        <span class="n">xml_force</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">xml_root</span><span class="p">,</span> <span class="s1">&#39;HarmonicAngleForce&#39;</span><span class="p">)</span>
        <span class="n">angles_done</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">tconv</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">degree</span><span class="o">.</span><span class="n">conversion_factor_to</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">radians</span><span class="p">)</span>
        <span class="n">kconv</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">kilocalorie</span><span class="o">.</span><span class="n">conversion_factor_to</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">kilojoule</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">),</span> <span class="n">angle</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">angle_types</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">((</span><span class="n">a</span> <span class="ow">in</span> <span class="n">skip_types</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">))):</span> <span class="k">continue</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">)</span> <span class="ow">in</span> <span class="n">angles_done</span><span class="p">:</span> <span class="k">continue</span>
            <span class="n">angles_done</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">))</span>
            <span class="n">angles_done</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">a3</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a1</span><span class="p">))</span>
            <span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">xml_force</span><span class="p">,</span> <span class="s1">&#39;Angle&#39;</span><span class="p">,</span> <span class="n">class1</span><span class="o">=</span><span class="n">a1</span><span class="p">,</span> <span class="n">class2</span><span class="o">=</span><span class="n">a2</span><span class="p">,</span> <span class="n">class3</span><span class="o">=</span><span class="n">a3</span><span class="p">,</span> <span class="n">angle</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">angle</span><span class="o">.</span><span class="n">theteq</span><span class="o">*</span><span class="n">tconv</span><span class="p">),</span> <span class="n">k</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">angle</span><span class="o">.</span><span class="n">k</span><span class="o">*</span><span class="n">kconv</span><span class="p">))</span>

    <span class="nd">@needs_lxml</span>
    <span class="k">def</span> <span class="nf">_write_omm_dihedrals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xml_root</span><span class="p">,</span> <span class="n">skip_types</span><span class="p">,</span> <span class="n">improper_dihedrals_ordering</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">dihedral_types</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">improper_periodic_types</span><span class="p">:</span> <span class="k">return</span>
        <span class="c1"># In ParameterSet, dihedral_types is *always* of type DihedralTypeList.</span>
        <span class="c1"># The from_structure method ensures that, even if the containing</span>
        <span class="c1"># Structure has separate dihedral entries for each torsion</span>
        <span class="k">if</span> <span class="n">improper_dihedrals_ordering</span> <span class="o">==</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span>
            <span class="n">xml_force</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">xml_root</span><span class="p">,</span> <span class="s1">&#39;PeriodicTorsionForce&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xml_force</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">xml_root</span><span class="p">,</span> <span class="s1">&#39;PeriodicTorsionForce&#39;</span><span class="p">,</span> <span class="n">ordering</span><span class="o">=</span><span class="n">improper_dihedrals_ordering</span><span class="p">)</span>
        <span class="n">diheds_done</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">pconv</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">degree</span><span class="o">.</span><span class="n">conversion_factor_to</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">radians</span><span class="p">)</span>
        <span class="n">kconv</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">kilocalorie</span><span class="o">.</span><span class="n">conversion_factor_to</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">kilojoule</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">nowild</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">name</span> <span class="k">if</span> <span class="n">name</span> <span class="o">!=</span> <span class="s1">&#39;X&#39;</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">,</span> <span class="n">a4</span><span class="p">),</span> <span class="n">dihed</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dihedral_types</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">((</span><span class="n">a</span> <span class="ow">in</span> <span class="n">skip_types</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">,</span> <span class="n">a4</span><span class="p">))):</span> <span class="k">continue</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">,</span> <span class="n">a4</span><span class="p">)</span> <span class="ow">in</span> <span class="n">diheds_done</span><span class="p">:</span> <span class="k">continue</span>
            <span class="n">diheds_done</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">,</span> <span class="n">a4</span><span class="p">))</span>
            <span class="n">diheds_done</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">a4</span><span class="p">,</span> <span class="n">a3</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a1</span><span class="p">))</span>
            <span class="n">terms</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">term</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dihed</span><span class="p">):</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">terms</span><span class="p">[</span><span class="s1">&#39;periodicity</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">term</span><span class="o">.</span><span class="n">per</span><span class="p">)</span>
                <span class="n">terms</span><span class="p">[</span><span class="s1">&#39;phase</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">term</span><span class="o">.</span><span class="n">phase</span><span class="o">*</span><span class="n">pconv</span><span class="p">)</span>
                <span class="n">terms</span><span class="p">[</span><span class="s1">&#39;k</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">term</span><span class="o">.</span><span class="n">phi_k</span><span class="o">*</span><span class="n">kconv</span><span class="p">)</span>
            <span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">xml_force</span><span class="p">,</span> <span class="s1">&#39;Proper&#39;</span><span class="p">,</span> <span class="n">class1</span><span class="o">=</span><span class="n">nowild</span><span class="p">(</span><span class="n">a1</span><span class="p">),</span> <span class="n">class2</span><span class="o">=</span><span class="n">a2</span><span class="p">,</span> <span class="n">class3</span><span class="o">=</span><span class="n">a3</span><span class="p">,</span> <span class="n">class4</span><span class="o">=</span><span class="n">nowild</span><span class="p">(</span><span class="n">a4</span><span class="p">),</span> <span class="o">**</span><span class="n">terms</span><span class="p">)</span>
        <span class="c1"># Now do the periodic impropers. OpenMM expects the central atom to be</span>
        <span class="c1"># listed first. ParameterSet goes out of its way to list it third</span>
        <span class="c1"># (consistent with Amber) except in instances where order is random (as</span>
        <span class="c1"># in CHARMM parameter files). But CHARMM parameter files don&#39;t have</span>
        <span class="c1"># periodic impropers, so we don&#39;t have to worry about that here.</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a4</span><span class="p">),</span> <span class="n">improp</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">improper_periodic_types</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">((</span><span class="n">a</span> <span class="ow">in</span> <span class="n">skip_types</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">,</span> <span class="n">a4</span><span class="p">))):</span> <span class="k">continue</span>
            <span class="c1"># Try to make the wild-cards in the middle</span>
            <span class="k">if</span> <span class="n">a4</span> <span class="o">==</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">a2</span> <span class="o">!=</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span>
                    <span class="n">a2</span><span class="p">,</span> <span class="n">a4</span> <span class="o">=</span> <span class="n">a4</span><span class="p">,</span> <span class="n">a2</span>
                <span class="k">elif</span> <span class="n">a3</span> <span class="o">!=</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span>
                    <span class="n">a3</span><span class="p">,</span> <span class="n">a4</span> <span class="o">=</span> <span class="n">a4</span><span class="p">,</span> <span class="n">a3</span>
            <span class="k">if</span> <span class="n">a2</span> <span class="o">!=</span> <span class="s1">&#39;X&#39;</span> <span class="ow">and</span> <span class="n">a3</span> <span class="o">==</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span>
                <span class="c1"># Single wild-card entries put the wild-card in position 2</span>
                <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span> <span class="o">=</span> <span class="n">a3</span><span class="p">,</span> <span class="n">a2</span>
            <span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">xml_force</span><span class="p">,</span> <span class="s1">&#39;Improper&#39;</span><span class="p">,</span> <span class="n">class1</span><span class="o">=</span><span class="n">a1</span><span class="p">,</span> <span class="n">class2</span><span class="o">=</span><span class="n">nowild</span><span class="p">(</span><span class="n">a2</span><span class="p">),</span> <span class="n">class3</span><span class="o">=</span><span class="n">nowild</span><span class="p">(</span><span class="n">a3</span><span class="p">),</span> <span class="n">class4</span><span class="o">=</span><span class="n">nowild</span><span class="p">(</span><span class="n">a4</span><span class="p">),</span>
                       <span class="n">periodicity1</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">improp</span><span class="o">.</span><span class="n">per</span><span class="p">),</span> <span class="n">phase1</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">improp</span><span class="o">.</span><span class="n">phase</span><span class="o">*</span><span class="n">pconv</span><span class="p">),</span> <span class="n">k1</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">improp</span><span class="o">.</span><span class="n">phi_k</span><span class="o">*</span><span class="n">kconv</span><span class="p">))</span>

    <span class="nd">@needs_lxml</span>
    <span class="k">def</span> <span class="nf">_write_omm_impropers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xml_root</span><span class="p">,</span> <span class="n">skip_types</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">improper_types</span><span class="p">:</span> <span class="k">return</span>
        <span class="n">xml_force</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">xml_root</span><span class="p">,</span> <span class="s1">&#39;CustomTorsionForce&#39;</span><span class="p">,</span> <span class="n">energy</span><span class="o">=</span><span class="s2">&quot;k*(theta-theta0)^2&quot;</span><span class="p">)</span>
        <span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">xml_force</span><span class="p">,</span> <span class="s1">&#39;PerTorsionParameter&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">)</span>
        <span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">xml_force</span><span class="p">,</span> <span class="s1">&#39;PerTorsionParameter&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;theta0&quot;</span><span class="p">)</span>
        <span class="n">kconv</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">kilocalorie</span><span class="o">.</span><span class="n">conversion_factor_to</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">kilojoule</span><span class="p">)</span>
        <span class="n">tconv</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">degree</span><span class="o">.</span><span class="n">conversion_factor_to</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">radian</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">nowild</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">name</span> <span class="k">if</span> <span class="n">name</span> <span class="o">!=</span> <span class="s1">&#39;X&#39;</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">,</span> <span class="n">a4</span><span class="p">),</span> <span class="n">improp</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">improper_types</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">((</span><span class="n">a</span> <span class="ow">in</span> <span class="n">skip_types</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">,</span> <span class="n">a4</span><span class="p">))):</span> <span class="k">continue</span>
            <span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">xml_force</span><span class="p">,</span> <span class="s1">&#39;Improper&#39;</span><span class="p">,</span> <span class="n">class1</span><span class="o">=</span><span class="n">nowild</span><span class="p">(</span><span class="n">a1</span><span class="p">),</span> <span class="n">class2</span><span class="o">=</span><span class="n">nowild</span><span class="p">(</span><span class="n">a2</span><span class="p">),</span> <span class="n">class3</span><span class="o">=</span><span class="n">nowild</span><span class="p">(</span><span class="n">a3</span><span class="p">),</span> <span class="n">class4</span><span class="o">=</span><span class="n">nowild</span><span class="p">(</span><span class="n">a4</span><span class="p">),</span>
                       <span class="n">k</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">improp</span><span class="o">.</span><span class="n">psi_k</span><span class="o">*</span><span class="n">kconv</span><span class="p">),</span> <span class="n">theta0</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">improp</span><span class="o">.</span><span class="n">psi_eq</span><span class="o">*</span><span class="n">tconv</span><span class="p">))</span>

    <span class="nd">@needs_lxml</span>
    <span class="k">def</span> <span class="nf">_write_omm_urey_bradley</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xml_root</span><span class="p">,</span> <span class="n">skip_types</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">urey_bradley_types</span><span class="p">:</span> <span class="k">return</span> <span class="kc">None</span>
        <span class="n">xml_root</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">etree</span><span class="o">.</span><span class="n">Comment</span><span class="p">(</span><span class="s2">&quot;Urey-Bradley terms&quot;</span><span class="p">)</span> <span class="p">)</span>
        <span class="n">xml_force</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">xml_root</span><span class="p">,</span> <span class="s1">&#39;AmoebaUreyBradleyForce&#39;</span><span class="p">)</span>
        <span class="n">length_conv</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">angstroms</span><span class="o">.</span><span class="n">conversion_factor_to</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">nanometers</span><span class="p">)</span>
        <span class="n">_ambfrc</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">kilocalorie_per_mole</span><span class="o">/</span><span class="n">u</span><span class="o">.</span><span class="n">angstrom</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">_ommfrc</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">kilojoule_per_mole</span><span class="o">/</span><span class="n">u</span><span class="o">.</span><span class="n">nanometer</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">frc_conv</span> <span class="o">=</span> <span class="n">_ambfrc</span><span class="o">.</span><span class="n">conversion_factor_to</span><span class="p">(</span><span class="n">_ommfrc</span><span class="p">)</span>
        <span class="n">ureys_done</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">),</span> <span class="n">urey</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">urey_bradley_types</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">((</span><span class="n">a</span> <span class="ow">in</span> <span class="n">skip_types</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">))):</span> <span class="k">continue</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">)</span> <span class="ow">in</span> <span class="n">ureys_done</span><span class="p">:</span> <span class="k">continue</span>
            <span class="k">if</span> <span class="n">urey</span> <span class="o">==</span> <span class="n">NoUreyBradley</span><span class="p">:</span> <span class="k">continue</span>
            <span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">xml_force</span><span class="p">,</span> <span class="s1">&#39;UreyBradley&#39;</span><span class="p">,</span> <span class="n">class1</span><span class="o">=</span><span class="n">a1</span><span class="p">,</span> <span class="n">class2</span><span class="o">=</span><span class="n">a2</span><span class="p">,</span> <span class="n">class3</span><span class="o">=</span><span class="n">a3</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">urey</span><span class="o">.</span><span class="n">req</span><span class="o">*</span><span class="n">length_conv</span><span class="p">),</span> <span class="n">k</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">urey</span><span class="o">.</span><span class="n">k</span><span class="o">*</span><span class="n">frc_conv</span><span class="p">))</span>

    <span class="nd">@needs_lxml</span>
    <span class="k">def</span> <span class="nf">_write_omm_cmaps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xml_root</span><span class="p">,</span> <span class="n">skip_types</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">cmap_types</span><span class="p">:</span> <span class="k">return</span>
        <span class="n">xml_force</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">xml_root</span><span class="p">,</span> <span class="s1">&#39;CMAPTorsionForce&#39;</span><span class="p">)</span>
        <span class="n">maps</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">econv</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">kilocalorie</span><span class="o">.</span><span class="n">conversion_factor_to</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">kilojoule</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">cmap</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cmap_types</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">cmap</span><span class="p">)</span> <span class="ow">in</span> <span class="n">maps</span><span class="p">:</span> <span class="k">continue</span>
            <span class="n">maps</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">cmap</span><span class="p">)]</span> <span class="o">=</span> <span class="n">counter</span>
            <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">xml_map</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">xml_force</span><span class="p">,</span> <span class="s1">&#39;Map&#39;</span><span class="p">)</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="n">cmap</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">switch_range</span><span class="p">()</span><span class="o">.</span><span class="n">T</span>
            <span class="n">map_string</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cmap</span><span class="o">.</span><span class="n">resolution</span><span class="p">):</span>
                <span class="n">base</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">cmap</span><span class="o">.</span><span class="n">resolution</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cmap</span><span class="o">.</span><span class="n">resolution</span><span class="p">):</span>
                    <span class="n">map_string</span> <span class="o">+=</span> <span class="s1">&#39; </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">base</span><span class="o">+</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">econv</span><span class="p">)</span>
                <span class="n">map_string</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="n">xml_map</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">map_string</span>
        <span class="n">used_torsions</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">,</span> <span class="n">a4</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">a5</span><span class="p">),</span> <span class="n">cmap</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cmap_types</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">((</span><span class="n">a</span> <span class="ow">in</span> <span class="n">skip_types</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">,</span> <span class="n">a4</span><span class="p">,</span> <span class="n">a5</span><span class="p">))):</span> <span class="k">continue</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">,</span> <span class="n">a4</span><span class="p">,</span> <span class="n">a5</span><span class="p">)</span> <span class="ow">in</span> <span class="n">used_torsions</span><span class="p">:</span> <span class="k">continue</span>
            <span class="n">used_torsions</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">,</span> <span class="n">a4</span><span class="p">,</span> <span class="n">a5</span><span class="p">))</span>
            <span class="n">used_torsions</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">a5</span><span class="p">,</span> <span class="n">a4</span><span class="p">,</span> <span class="n">a3</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a1</span><span class="p">))</span>
            <span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">xml_force</span><span class="p">,</span> <span class="s1">&#39;Torsion&#39;</span><span class="p">,</span> <span class="nb">map</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">maps</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">cmap</span><span class="p">)]),</span>
                       <span class="n">class1</span><span class="o">=</span><span class="n">a1</span><span class="p">,</span> <span class="n">class2</span><span class="o">=</span><span class="n">a2</span><span class="p">,</span> <span class="n">class3</span><span class="o">=</span><span class="n">a3</span><span class="p">,</span> <span class="n">class4</span><span class="o">=</span><span class="n">a4</span><span class="p">,</span> <span class="n">class5</span><span class="o">=</span><span class="n">a5</span><span class="p">)</span>

    <span class="nd">@needs_lxml</span>
    <span class="k">def</span> <span class="nf">_write_omm_nonbonded</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xml_root</span><span class="p">,</span> <span class="n">skip_types</span><span class="p">,</span> <span class="n">separate_ljforce</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom_types</span><span class="p">:</span> <span class="k">return</span>
        <span class="c1"># Compute conversion factors for writing in natrual OpenMM units.</span>
        <span class="n">length_conv</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">angstrom</span><span class="o">.</span><span class="n">conversion_factor_to</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">nanometer</span><span class="p">)</span>
        <span class="n">ene_conv</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">kilocalories</span><span class="o">.</span><span class="n">conversion_factor_to</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">kilojoules</span><span class="p">)</span>

        <span class="c1"># Get the 1-4 scaling factors from the torsion list</span>
        <span class="n">scee</span><span class="p">,</span> <span class="n">scnb</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(),</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dihedral_types</span><span class="p">:</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dihedral_types</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">dt</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">scee</span><span class="p">:</span> <span class="n">scee</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">scee</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">scnb</span><span class="p">:</span> <span class="n">scnb</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">scnb</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">scee</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Cannot currently handle mixed 1-4 &#39;</span>
                    <span class="s1">&#39;scaling: Elec. Scaling factors </span><span class="si">%s</span><span class="s1"> detected&#39;</span> <span class="o">%</span>
                    <span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">scee</span><span class="p">])))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">scnb</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Cannot currently handle mixed 1-4 &#39;</span>
                    <span class="s1">&#39;scaling: L-J Scaling factors </span><span class="si">%s</span><span class="s1"> detected&#39;</span> <span class="o">%</span>
                    <span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">scnb</span><span class="p">])))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">scee</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">coulomb14scale</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">scee</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">coulomb14scale</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_scee</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">scnb</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">lj14scale</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">scnb</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lj14scale</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_scnb</span>

        <span class="c1"># Write NonbondedForce records.</span>
        <span class="n">xml_force</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">xml_root</span><span class="p">,</span> <span class="s1">&#39;NonbondedForce&#39;</span><span class="p">,</span> <span class="n">coulomb14scale</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">coulomb14scale</span><span class="p">),</span> <span class="n">lj14scale</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">lj14scale</span><span class="p">))</span>
        <span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">xml_force</span><span class="p">,</span> <span class="s1">&#39;UseAttributeFromResidue&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;charge&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">atom_type</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atom_types</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">skip_types</span><span class="p">:</span> <span class="k">continue</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">atom_type</span><span class="o">.</span><span class="n">rmin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">atom_type</span><span class="o">.</span><span class="n">epsilon</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                <span class="n">sigma</span> <span class="o">=</span> <span class="n">atom_type</span><span class="o">.</span><span class="n">sigma</span> <span class="o">*</span> <span class="n">length_conv</span>  <span class="c1"># in md_unit_system</span>
                <span class="n">epsilon</span> <span class="o">=</span> <span class="n">atom_type</span><span class="o">.</span><span class="n">epsilon</span> <span class="o">*</span> <span class="n">ene_conv</span> <span class="c1"># in md_unit_system</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Dummy atom</span>
                <span class="n">sigma</span> <span class="o">=</span> <span class="mf">1.0</span>
                <span class="n">epsilon</span> <span class="o">=</span> <span class="mf">0.0</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbfix_types</span> <span class="ow">or</span> <span class="n">separate_ljforce</span><span class="p">:</span>
                <span class="c1"># turn off L-J. Will use LennardJonesForce to use CostumNonbondedForce to compute L-J interactions</span>
                <span class="n">sigma</span> <span class="o">=</span> <span class="mf">1.0</span>
                <span class="n">epsilon</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># NonbondedForce cannot handle distinct 14 parameters</span>
                <span class="c1"># We need to use a separate LennardJonesForce instead</span>
                <span class="c1"># TODO: Can we autodetect this and switch on separate_ljforce earlier?</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">atom_type</span><span class="o">.</span><span class="n">rmin_14</span> <span class="o">!=</span> <span class="n">atom_type</span><span class="o">.</span><span class="n">rmin</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">atom_type</span><span class="o">.</span><span class="n">epsilon_14</span> <span class="o">!=</span> <span class="n">atom_type</span><span class="o">.</span><span class="n">epsilon</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;OpenMM &lt;NonbondedForce&gt; cannot handle &#39;</span>
                        <span class="s1">&#39;distinct 1-4 sigma and epsilon parameters; &#39;</span>
                        <span class="s1">&#39;use separate_ljforce=True instead&#39;</span><span class="p">)</span>

            <span class="c1"># Ensure we don&#39;t have sigma = 0</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">sigma</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">epsilon</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">):</span>
                    <span class="n">sigma</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="c1"># reset sigma = 1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;For atom type &#39;</span><span class="si">%s</span><span class="s2">&#39;, sigma = 0 but &quot;</span>
                                     <span class="s2">&quot;epsilon != 0.&quot;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>

            <span class="n">attributes</span> <span class="o">=</span> <span class="p">{</span> <span class="s1">&#39;class&#39;</span> <span class="p">:</span> <span class="n">name</span><span class="p">,</span> <span class="s1">&#39;sigma&#39;</span> <span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">sigma</span><span class="p">),</span> <span class="s1">&#39;epsilon&#39;</span> <span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">epsilon</span><span class="p">))</span> <span class="p">}</span>
            <span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">xml_force</span><span class="p">,</span> <span class="s1">&#39;Atom&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">attributes</span><span class="p">)</span>

    <span class="nd">@needs_lxml</span>
    <span class="k">def</span> <span class="nf">_write_omm_LennardJonesForce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xml_root</span><span class="p">,</span> <span class="n">skip_types</span><span class="p">,</span> <span class="n">separate_ljforce</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbfix_types</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">separate_ljforce</span><span class="p">:</span> <span class="k">return</span>
        <span class="c1"># Convert Conversion factors for writing in natural OpenMM units</span>
        <span class="n">length_conv</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">angstrom</span><span class="o">.</span><span class="n">conversion_factor_to</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">nanometer</span><span class="p">)</span>
        <span class="n">ene_conv</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">kilocalories</span><span class="o">.</span><span class="n">conversion_factor_to</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">kilojoules</span><span class="p">)</span>

        <span class="n">scnb</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dihedral_types</span><span class="p">:</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dihedral_types</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">dt</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">scnb</span><span class="p">:</span> <span class="n">scnb</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">scnb</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">scnb</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Cannot currently handle mixed 1-4 &#39;</span>
                    <span class="s1">&#39;scaling: L-J Scaling factors </span><span class="si">%s</span><span class="s1"> detected&#39;</span> <span class="o">%</span>
                    <span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">scnb</span><span class="p">])))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">scnb</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">lj14scale</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">scnb</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lj14scale</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_scnb</span>

        <span class="c1"># write L-J records</span>
        <span class="n">xml_force</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">xml_root</span><span class="p">,</span> <span class="s1">&#39;LennardJonesForce&#39;</span><span class="p">,</span> <span class="n">lj14scale</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">lj14scale</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">atom_type</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atom_types</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">skip_types</span><span class="p">:</span> <span class="k">continue</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">atom_type</span><span class="o">.</span><span class="n">rmin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">atom_type</span><span class="o">.</span><span class="n">epsilon</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                <span class="n">sigma</span> <span class="o">=</span> <span class="n">atom_type</span><span class="o">.</span><span class="n">sigma</span> <span class="o">*</span> <span class="n">length_conv</span>  <span class="c1"># in md_unit_system</span>
                <span class="n">epsilon</span> <span class="o">=</span> <span class="n">atom_type</span><span class="o">.</span><span class="n">epsilon</span> <span class="o">*</span> <span class="n">ene_conv</span> <span class="c1"># in md_unit_system</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Dummy atom</span>
                <span class="n">sigma</span> <span class="o">=</span> <span class="mf">1.0</span>
                <span class="n">epsilon</span> <span class="o">=</span> <span class="mf">0.0</span>

            <span class="c1"># Ensure we don&#39;t have sigma = 0</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">sigma</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">epsilon</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">):</span>
                    <span class="n">sigma</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="c1"># reset sigma = 1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;For atom type &#39;</span><span class="si">%s</span><span class="s2">&#39;, sigma = 0 but &quot;</span>
                                     <span class="s2">&quot;epsilon != 0.&quot;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>

            <span class="c1"># Handle special values used for 14 interactions</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">atom_type</span><span class="o">.</span><span class="n">rmin_14</span> <span class="o">!=</span> <span class="n">atom_type</span><span class="o">.</span><span class="n">rmin</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">atom_type</span><span class="o">.</span><span class="n">epsilon_14</span> <span class="o">!=</span> <span class="n">atom_type</span><span class="o">.</span><span class="n">epsilon</span><span class="p">):</span>
                <span class="n">sigma14</span> <span class="o">=</span> <span class="n">atom_type</span><span class="o">.</span><span class="n">sigma_14</span> <span class="o">*</span> <span class="n">length_conv</span>  <span class="c1"># in md_unit_system</span>
                <span class="n">epsilon14</span> <span class="o">=</span> <span class="n">atom_type</span><span class="o">.</span><span class="n">epsilon_14</span> <span class="o">*</span> <span class="n">ene_conv</span> <span class="c1"># in md_unit_system</span>

                <span class="c1"># Ensure we don&#39;t have sigma = 0</span>
                <span class="k">if</span> <span class="n">sigma14</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">epsilon14</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">):</span>
                        <span class="n">sigma14</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="c1"># reset sigma = 1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;For atom type &#39;</span><span class="si">%s</span><span class="s2">&#39;, sigma_14 = 0 but &quot;</span>
                                        <span class="s2">&quot;epsilon_14 != 0.&quot;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sigma14</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">epsilon14</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="n">attributes</span> <span class="o">=</span> <span class="p">{</span> <span class="s1">&#39;class&#39;</span> <span class="p">:</span> <span class="n">name</span><span class="p">,</span> <span class="s1">&#39;sigma&#39;</span> <span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">sigma</span><span class="p">),</span> <span class="s1">&#39;epsilon&#39;</span> <span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">epsilon</span><span class="p">))</span> <span class="p">}</span>
            <span class="k">if</span> <span class="n">epsilon14</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">attributes</span><span class="p">[</span><span class="s1">&#39;epsilon14&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">epsilon14</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">sigma14</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">attributes</span><span class="p">[</span><span class="s1">&#39;sigma14&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">sigma14</span><span class="p">)</span>
            <span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">xml_force</span><span class="p">,</span> <span class="s1">&#39;Atom&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">attributes</span><span class="p">)</span>

        <span class="c1"># write NBFIX records</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">atom_types</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbfix_types</span><span class="p">):</span>
            <span class="n">emin</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">ene_conv</span>
            <span class="n">rmin</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">length_conv</span>
            <span class="c1"># convert to sigma; note that NBFIX types are not rmin/2 but rmin</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">rmin</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="mi">6</span><span class="p">))</span>
            <span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">xml_force</span><span class="p">,</span> <span class="s1">&#39;NBFixPair&#39;</span><span class="p">,</span> <span class="n">class1</span><span class="o">=</span><span class="n">atom_types</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">class2</span><span class="o">=</span><span class="n">atom_types</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">sigma</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">sigma</span><span class="p">),</span> <span class="n">epsilon</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">emin</span><span class="p">))</span>

    <span class="nd">@needs_lxml</span>
    <span class="k">def</span> <span class="nf">_write_omm_DrudeForce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xml_root</span><span class="p">,</span> <span class="n">skip_types</span><span class="p">):</span>
        <span class="c1"># Find all atoms with Drude particles.</span>
        <span class="n">drude_atoms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">residue</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">residues</span><span class="o">.</span><span class="n">values</span><span class="p">())</span><span class="o">+</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">patches</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">residue</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="n">DrudeAtom</span><span class="p">):</span>
                    <span class="n">drude_atoms</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">atom</span><span class="p">,</span> <span class="n">residue</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">drude_atoms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique_atom_types</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Drude particles require unique_atom_types&#39;</span><span class="p">)</span>
        <span class="n">xml_force</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">xml_root</span><span class="p">,</span> <span class="s1">&#39;DrudeForce&#39;</span><span class="p">)</span>
        <span class="n">alpha_scale</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">angstrom</span><span class="o">/</span><span class="n">u</span><span class="o">.</span><span class="n">nanometers</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span>
        <span class="k">for</span> <span class="n">atom</span><span class="p">,</span> <span class="n">residue</span> <span class="ow">in</span> <span class="n">drude_atoms</span><span class="p">:</span>
            <span class="n">attributes</span> <span class="o">=</span> <span class="p">{</span> <span class="s1">&#39;type1&#39;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_mm_atom_type</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="n">residue</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span> <span class="s1">&#39;type2&#39;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_mm_atom_type</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="n">residue</span><span class="p">),</span>
                           <span class="s1">&#39;charge&#39;</span> <span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">drude_charge</span><span class="p">),</span> <span class="s1">&#39;polarizability&#39;</span> <span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">alpha_scale</span><span class="o">*</span><span class="n">atom</span><span class="o">.</span><span class="n">alpha</span><span class="p">)),</span>
                           <span class="s1">&#39;thole&#39;</span> <span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">thole</span><span class="p">)</span> <span class="p">}</span>
            <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">anisotropy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">aniso</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">anisotropy</span>
                <span class="n">attributes</span><span class="p">[</span><span class="s1">&#39;type3&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_mm_atom_type</span><span class="p">(</span><span class="n">aniso</span><span class="o">.</span><span class="n">atom2</span><span class="p">,</span> <span class="n">residue</span><span class="p">)</span>
                <span class="n">attributes</span><span class="p">[</span><span class="s1">&#39;type4&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_mm_atom_type</span><span class="p">(</span><span class="n">aniso</span><span class="o">.</span><span class="n">atom3</span><span class="p">,</span> <span class="n">residue</span><span class="p">)</span>
                <span class="n">attributes</span><span class="p">[</span><span class="s1">&#39;type5&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_mm_atom_type</span><span class="p">(</span><span class="n">aniso</span><span class="o">.</span><span class="n">atom4</span><span class="p">,</span> <span class="n">residue</span><span class="p">)</span>
                <span class="n">attributes</span><span class="p">[</span><span class="s1">&#39;aniso12&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">aniso</span><span class="o">.</span><span class="n">a11</span><span class="p">)</span>
                <span class="n">attributes</span><span class="p">[</span><span class="s1">&#39;aniso34&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">aniso</span><span class="o">.</span><span class="n">a22</span><span class="p">)</span>
            <span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">xml_force</span><span class="p">,</span> <span class="s1">&#39;Particle&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">attributes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_write_omm_scripts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">skip_types</span><span class="p">):</span>
        <span class="c1"># Not currently implemented, so throw an exception if any unsupported</span>
        <span class="c1"># options are specified</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">combining_rule</span> <span class="o">==</span> <span class="s1">&#39;geometric&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Geometric combining rule not currently supported.&#39;</span><span class="p">)</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2015, Jason Swails

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>